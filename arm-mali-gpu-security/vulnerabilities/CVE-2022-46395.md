# Race Condition Vulnerability Analysis in Mali GPU Driver

During the analysis of the memory management mechanism in the Mali GPU driver, a severe race condition vulnerability was discovered, which can lead to a Use-After-Free (UAF) issue. Below is a detailed analysis of this vulnerability:

## Background and Memory Management Mechanism

When a user-space application uses the Mali GPU, it needs to open the device node and initialize a `kbase_context` kernel object to manage related resources. The `kbase_context` is responsible for managing shared memory resources that are used for communication between the GPU device space and user-space applications. The application can request this type of memory through the `ioctl` interface `KBASE_IOCTL_MEM_IMPORT`, which is owned by the user-space application.

![image](https://github.com/Scripterdoge/ARM/assets/54847959/32a910f3-71ed-402c-a9d7-99bb9bcf64a2)

To track the pages being used by the GPU, `kbase_mem_phy_alloc` uses a page array to maintain page information. In the GPU, the function `kbase_vmap_prot` can be used to temporarily map the physical pages of a memory region to the CPU-side kernel space. The `kbase_vmap_struct` is used to manage the reference count during the mapping period to prevent UAF when the memory region's page resources are reduced during the mapping process.

![image](https://github.com/Scripterdoge/ARM/assets/54847959/08275916-ddbc-47cb-9eaf-068e5dc0776a)


## Resource Shrinking Operation

When performing a memory region page resource shrinking operation, the system checks if the `kernel_mappings` value is zero to ensure that UAF will not occur after the mapping. The prototype function for shrinking memory region page resources is `kbase_mem_shrink`, which is wrapped in the resource lock of each `kbase_context` to ensure safety.
![image](https://github.com/Scripterdoge/ARM/assets/54847959/62d3ac87-deb9-4453-a9cc-4b6de5b45de7)

## Root Cause of the Issue

However, the problem lies in another `ioctl` interface, `KBASE_IOCTL_STICKY_RESOURCE_UNMAP`, which is not protected by the resource lock. This interface can cause the memory region page resources to shrink without resource lock protection. This means that all scenarios where `kbase_vmap_prot` is used for kernel page table mapping are subject to race conditions that can lead to UAF issues.

Specifically, when the `KBASE_IOCTL_STICKY_RESOURCE_UNMAP` interface is used, it can shrink the memory region's page resources without appropriate synchronization. In such a case, if another thread simultaneously performs kernel page table mapping using `kbase_vmap_prot`, it will lead to a reference count error, causing a UAF vulnerability.

![image](https://github.com/Scripterdoge/ARM/assets/54847959/4c488600-3a28-4420-9f52-e9d81be866e1)

## Vulnerability Exploitation

Attackers can exploit this race condition vulnerability by carefully crafting concurrent operations to induce UAF, thereby achieving arbitrary code execution. The specific steps may include:

1. **Request Shared Memory**: Request the necessary shared memory region through `KBASE_IOCTL_MEM_IMPORT`.
2. **Perform Temporary Mapping**: Use the `kbase_vmap_prot` function to temporarily map the shared memory region to the CPU-side kernel space.
3. **Trigger Resource Shrinking**: Trigger the memory region's page resource shrinking operation through the `KBASE_IOCTL_STICKY_RESOURCE_UNMAP` interface.
4. **Exploit the UAF Vulnerability**: Under race conditions, force the memory region's page resources to shrink, causing a reference count error and leading to UAF.

## Mitigation Measures

To prevent this race condition vulnerability, all operations that might cause the memory region's page resources to shrink must be protected by appropriate resource locks. Specific measures may include:

1. **Modify the `KBASE_IOCTL_STICKY_RESOURCE_UNMAP` Interface**: Ensure that this interface is also protected by the `kbase_context` resource lock when performing resource shrinking operations.
2. **Increase Reference Count Protection**: Add appropriate synchronization mechanisms in all code paths involving reference count operations to prevent race conditions.

With these measures, similar UAF vulnerabilities can be effectively prevented, enhancing system security.
